//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : StateMachine.sm
//

#include "darts_fsm/StateMachine.h"
#include "StateMachine_sm.h"

using namespace statemap;

// Static class declarations.
StateMachineMap_Idle StateMachineMap::Idle("StateMachineMap::Idle", 0);
StateMachineMap_Ready StateMachineMap::Ready("StateMachineMap::Ready", 1);
StateMachineMap_Push StateMachineMap::Push("StateMachineMap::Push", 2);
StateMachineMap_Back StateMachineMap::Back("StateMachineMap::Back", 3);

void StateMachineState::dbusUpdate(StateMachineContext& context, rm_msgs::DbusData data_dbus_)
{
    Default(context);
}

void StateMachineState::Default(StateMachineContext& context)
{
    throw (
        TransitionUndefinedException(
            (context.getState()).getName(),
            context.getTransition()));

}

void StateMachineMap_Idle::dbusUpdate(StateMachineContext& context, rm_msgs::DbusData data_dbus_)
{
    StateMachine& ctxt = context.getOwner();

    if ( ctxt.isReady(data_dbus_) == true )
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.initReady();
            context.setState(StateMachineMap::Ready);
        }
        catch (...)
        {
            context.setState(StateMachineMap::Ready);
            throw;
        }
        context.getState().Entry(context);
    }
    else if ( ctxt.isBack(data_dbus_) == true )

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.initBack();
            context.setState(StateMachineMap::Back);
        }
        catch (...)
        {
            context.setState(StateMachineMap::Back);
            throw;
        }
        context.getState().Entry(context);
    }

}

void StateMachineMap_Ready::dbusUpdate(StateMachineContext& context, rm_msgs::DbusData data_dbus_)
{
    StateMachine& ctxt = context.getOwner();

    if ( ctxt.isPush(data_dbus_) == true )
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.initPush();
            context.setState(StateMachineMap::Push);
        }
        catch (...)
        {
            context.setState(StateMachineMap::Push);
            throw;
        }
        context.getState().Entry(context);
    }
    else if ( ctxt.isBack(data_dbus_) == true )

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.initBack();
            context.setState(StateMachineMap::Back);
        }
        catch (...)
        {
            context.setState(StateMachineMap::Back);
            throw;
        }
        context.getState().Entry(context);
    }

}

void StateMachineMap_Push::dbusUpdate(StateMachineContext& context, rm_msgs::DbusData data_dbus_)
{
    StateMachine& ctxt = context.getOwner();

    if ( ctxt.isReady(data_dbus_) == true )
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.initReady();
            context.setState(StateMachineMap::Ready);
        }
        catch (...)
        {
            context.setState(StateMachineMap::Ready);
            throw;
        }
        context.getState().Entry(context);
    }

}

void StateMachineMap_Back::dbusUpdate(StateMachineContext& context, rm_msgs::DbusData data_dbus_)
{
    StateMachine& ctxt = context.getOwner();

    if ( ctxt.isPush(data_dbus_) == true )
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.initPush();
            context.setState(StateMachineMap::Push);
        }
        catch (...)
        {
            context.setState(StateMachineMap::Push);
            throw;
        }
        context.getState().Entry(context);
    }

}

//
// Local variables:
//  buffer-read-only: t
// End:
//
